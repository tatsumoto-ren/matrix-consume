#!/bin/bash

set -euo pipefail

readonly \
	lock=.matrix-consume.lock \
	units_dir=${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user

program() {
	basename -- "$(readlink -f -- "$0")"
}

help() {
	echo "Usage: $(program) [-c FILE] [-t NUMBER] [-w]"
	echo
	echo "An automatic matrix image uploader."
	echo "The script uploads images from a folder on your computer to a specified Matrix room."
	echo "You can also watch the folder for new images moved into it and upload them automatically."
	echo "The files are deleted locally after uploading."
	echo
	echo "Options:"
	column -t -s'|' <<-'EOF'
		-h, --help|display this help text and exit.
		-c, --config|Path to config file.
		-t, --timeout|Timeout between uploads in seconds.
		-w, --watch|Watch for new files in directory.
		-o, --one-shot|Upload one file and exit instead of uploading all files from directory.
		--help-config|display config file help text and exit.
		--systemd-init|Create systemd unit and timer files for the current user.
		--systemd-cleanup|Disable systemd unit and timer files for the current user, stop if running, and delete the files.
	EOF
}

help_config() {
	echo "$(program) config:"
	column -t -s'|' <<-'EOF'
		token|Access token. In Element can be obtained by going to "Settings" > "Help & About".
		server|Address of a Matrix server.
		dir|Local directory to source images from.
		timeout|Sleep time between uploads. The number can end with 's' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for days.
		watch|If 'true', wait for new files in the directory. Otherwise exit after all files have been uploaded.
		socks5|Optional, can be set to a socks5 proxy. E.g, '127.0.0.1:9050'.
		connect_timeout|Optional, curl connect timeout, in seconds. By default, 30 seconds.
		max_time|Optional, curl maximum transfer time, in seconds. By default, 180 seconds.
		one_shot|Optional, if 'true', upload one image and exit.
	EOF
}

die() {
	echo "$*" >&2
	exit 1
}

read_config() {
	if [[ -f ${config_filepath:?} ]]; then
		# shellcheck disable=SC1090
		source -- <(grep -xP '^[5a-z_]+=.+$' -- "$config_filepath")
	else
		die "Can't read config file: $config_filepath"
	fi
	readonly room_id \
		token \
		dir=${dir%/} \
		server=${server#https://} \
		timeout=${op_timeout:-${timeout:-3}} \
		watch=${op_watch:-${watch:-false}} \
		socks5=${socks5-} \
		connect_timeout=${connect_timeout:-30} \
		max_time=${max_time:-180} \
		one_shot=${op_one_shot:-${one_shot:-false}}
	check_config
}

check_config() {
	if [[ $watch != true ]] && [[ $watch != false ]]; then
		die "'watch' should be set to 'true' or 'false'."
	fi
	if ! [[ -d $dir ]]; then
		die "Can't locate directory $dir"
	fi
	if ! [[ $server == *.* ]]; then
		die "Invalid server address"
	fi
	if ! [[ $room_id =~ ^![a-zA-Z]+:[^:]+$ ]]; then
		die "Invalid room id, should be like this: '!UoSbpJOhdaqhNldLDv:server.domain'"
	fi
	if ! [[ $token =~ ^[0-9a-zA-Z_]+$ ]]; then
		die "Access token should contain only alphanumeric characters."
	fi
	if ! [[ $timeout =~ [0-9]+[smhd]? ]]; then
		die "Set timeout to a number, in seconds or with a suffix on the end."
	fi
	if [[ -n $socks5 ]] && [[ $socks5 != *:* ]]; then
		die "Invalid socks5 proxy. Specify 'address:port', e.g. '127.0.0.1:9050'."
	fi
	if ! [[ $connect_timeout =~ [0-9]+ ]]; then
		die "Set 'connect_timeout' to a number, in seconds."
	fi
	if ! [[ $max_time =~ [0-9]+ ]]; then
		die "Set 'max_time' to a number, in seconds."
	fi
	if [[ $one_shot != true ]] && [[ $one_shot != false ]]; then
		die "'one_shot' should be set to 'true' or 'false'."
	fi
}

_curl() {
	curl \
		--connect-timeout "$connect_timeout" \
		--max-time "$max_time" \
		--socks5-hostname "$socks5" \
		"$@"
}

upload_image() {
	_curl --silent \
		--request POST \
		--data-binary "@$image_filepath" \
		--header "Accept: application/json" \
		--header "Content-Type: ${mime_type:?}" \
		--header "Authorization: Bearer $token" \
		"https://$server/_matrix/media/v3/upload"
}

delete_image() {
	if gio trash -- "${image_filepath:?}" || trash-put -- "${image_filepath:?}"; then
		echo "${image_filepath##*/} moved to trash."
	elif [[ -f "${image_filepath:?}" ]]; then
		if rm -- "${image_filepath:?}"; then
			echo "${image_filepath##*/} deleted."
		else
			die "Error: ${image_filepath##*/} wasn't deleted."
		fi
	fi
}

post_image() {
	local content='{
		"body": "<FILENAME>",
		"info": {
			"w": <WIDTH>,
			"h": <HEIGHT>,
			"mimetype": "<MIMETYPE>",
			"size": <SIZE>,
			"thumbnail_url": "<MXC>",
			"thumbnail_info": {
				"w": <WIDTH>,
				"h": <HEIGHT>,
				"mimetype": "<MIMETYPE>",
				"size": <SIZE>
			}
		},
		"msgtype": "m.image",
		"url": "<MXC>"
	}'
	content=${content//<FILENAME>/${RANDOM}.${mime_type##*/}}
	content=${content//<MXC>/$mxc}
	content=${content//<MIMETYPE>/$mime_type}
	content=${content//<SIZE>/$size}
	content=${content//<WIDTH>/${w_h%,*}}
	content=${content//<HEIGHT>/${w_h#*,}}
	_curl --silent \
		--request POST \
		--header "Authorization: Bearer $token" \
		--header "Accept: application/json" \
		--header "Content-Type: application/json" \
		--data "$content" \
		"https://${server}/_matrix/client/v3/rooms/${room_id}/send/m.room.message"
}

unit_name() {
	tr -cd '[:alnum:]._-' <<<"$(program)-${room_id:?}"
}

check_systemctl() {
	if ! command -v systemctl >/dev/null 2>&1; then
		die "This system doesn't appear to have systemctl."
	fi
}

systemd_init() {
	check_systemctl

	local -r name=$(unit_name)
	local -r unit_filepath=$units_dir/$name.service
	local -r timer_filepath=$units_dir/$name.timer
	local -r executable=$(readlink -f -- "$0")

	mkdir -p -- "$units_dir"

	cat <<-EOF >"$unit_filepath"
		[Unit]
		Description=Matrix Consume for room $room_id
		After=network.target

		[Service]
		Type=simple
		ExecStart="$executable" -c "$config_filepath"

		[Install]
		WantedBy=default.target
	EOF
	echo "Created unit file $unit_filepath."

	cat <<-EOF >"$timer_filepath"
		[Unit]
		Description=Run Matrix Consume periodically for room $room_id.

		[Timer]
		OnBootSec=1min
		OnUnitActiveSec=10min

		[Install]
		WantedBy=timers.target
	EOF
	echo "Created timer file $timer_filepath"

	systemctl --user daemon-reload

	echo "Edit the files to adjust run parameters or timeouts."
	echo "Use 'systemctl --user --all [start|enable] NAME.[timer|service]' to start or enable."
}

systemd_cleanup() {
	check_systemctl

	local -r unit_filepath=$units_dir/$(unit_name).service
	local -r timer_filepath=${unit_filepath%.service}.timer

	systemctl --user disable "${timer_filepath##*/}" || true
	systemctl --user stop "${timer_filepath##*/}" || true

	systemctl --user disable "${unit_filepath##*/}" || true
	systemctl --user stop "${unit_filepath##*/}" || true

	rm -v -- "$unit_filepath" "$timer_filepath" || true

	echo "Done."
}

handle_file() {
	local -r image_filepath=${1:?}
	local -r mime_type=$(file -b --mime-type -- "$image_filepath")

	if [[ $image_filepath =~ \.(jpe?g|png|gif|webp)$ ]] && [[ $mime_type == image/* ]]; then
		local -r w_h=$(identify -format '%w,%h\n' -- "$image_filepath" | head -1)
		local -r size=$(du -Hb -- "$image_filepath" | cut -f 1)
		local -r mxc=$(upload_image | grep -Po '"content_uri":\s*"\Kmxc://[^"]+(?=")')

		if [[ -n $mxc ]] && [[ $(post_image) == '{"event_id":"$'*'"}' ]]; then
			echo "Uploaded ${image_filepath##*/}"
			delete_image
		else
			die "Couldn't upload ${image_filepath##*/}"
		fi
	fi
}

is_dir_occupied() {
	[[ -f "$dir/$lock" ]] && kill -0 "$(cat -- "$dir/$lock")" 2>/dev/null
}

mark_dir_occupied() {
	echo $$ >"$dir/$lock"
}

check_dir_occupied() {
	if is_dir_occupied; then
		die "There's already PID $(cat -- "$dir/$lock") working in $dir"
	else
		mark_dir_occupied
	fi
}

find_files() {
	find "$dir" -maxdepth 1 -type f -printf '%f\n'
}

monitor_folder() {
	inotifywait --monitor --quiet --event close_write,moved_to --format '%f' -- "$dir"
}

stream_files() {
	find_files | shuf
	if [[ $watch == true ]]; then
		monitor_folder
	fi
}

loop() {
	check_dir_occupied
	stream_files | while read -r filename; do
		if [[ -f "$dir/$filename" ]]; then
			handle_file "$dir/$filename"
			if [[ $one_shot == true ]]; then
				exit
			else
				sleep "${timeout:?}"
			fi
		fi
	done
}

main() {
	while :; do
		case ${1-} in
		-h | --help)
			help
			exit
			;;
		--help-config)
			help_config
			exit
			;;
		-c | --config)
			shift
			config_filepath=${1:?Config path is not set.}
			;;
		-t | --timeout)
			shift
			local -r op_timeout=${1:?Timeout is not set.}
			;;
		-w | --watch)
			local -r op_watch=true
			;;
		-o | --one-shot)
			local -r op_one_shot=true
			;;
		--systemd-init)
			local -r main_action=systemd_init
			;;
		--systemd-cleanup)
			local -r main_action=systemd_cleanup
			;;
		"")
			break
			;;
		*)
			die "Unknown command: '$1'."
			;;
		esac
		shift
	done
	readonly config_filepath=${config_filepath:-${XDG_CONFIG_HOME:-$HOME/.config}/matrix-consume/config}
	read_config
	"${main_action:-loop}"
}

main "$@"
